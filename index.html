<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Memory Game</title>
    <script src="https://cdn.jsdelivr.net/gh/volumetrics-io/mrjs/dist/mr.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body>
    <mr-app debug="true">
        <mr-entity data-comp-anchor="type:fixed; label:table;" id="game-container" data-position="0 2 0.5">
            <mr-light color="#000000" intensity="10" data-position="0 1 0"></mr-light>
            <mr-panel class="bottom-panel">
                <mr-button class="play-button">Play</mr-button>
            </mr-panel>

            <!-- Models will be dynamically created and added here -->
            <mr-entity id="models"></mr-entity>
            <mr-entity id="volume" style="visibility: hidden;">
                <mr-entity id="paintings"></mr-entity>
            </mr-entity>
        </mr-entity>
    </mr-app>

    <script>
        class MRPainting extends MREntity {
            constructor() {
                super();
                const geometry = new THREE.BoxGeometry(0.99, 0.99, 0.99);
                const material = new THREE.MeshPhongMaterial({
                    color: '#0235ff',
                    side: 2,
                    transparent: true,
                    opacity: 0,
                    specular: '#7989c4',
                    clipping: true
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.object3D.add(this.mesh);
            }
        }

        customElements.define('mr-painting', MRPainting);

        const __appState = {
            selected: 0,
            debugToggle: false,
            models: [
                { name: "model1", src: "./models/model1.glb", position: "0 0 0", rotation: "90 0 0" },
                { name: "model2", src: "./models/model2.glb", position: "0 0 0", rotation: "90 0 0" },
                { name: "model3", src: "./models/model3.glb", position: "0 0 0", rotation: "90 0 0" },
                { name: "model4", src: "./models/model4.glb", position: "0 0 0", rotation: "90 0 0" },
                { name: "model5", src: "./models/model5.glb", position: "0 0 0", rotation: "90 0 0" }
            ]
        };

        const handler = {
            set(target, property, value) {
                target[property] = value;
                render();
                return true;
            }
        };

        const App = new Proxy(__appState, handler);

        function render() {
            const modelsContainer = document.getElementById('models');
            const paintingsContainer = document.getElementById('paintings');

            modelsContainer.innerHTML = '';
            paintingsContainer.innerHTML = '';

            App.models.forEach(modelData => {
                const model = document.createElement('mr-model');
                model.setAttribute('src', modelData.src);
                model.setAttribute('data-position', modelData.position);
                model.setAttribute('data-rotation', modelData.rotation);
                model.dataset.name = modelData.name;
                modelsContainer.appendChild(model);

                const painting = document.createElement('mr-painting');
                painting.dataset.name = modelData.name;
                paintingsContainer.appendChild(painting);
            });

            addEventListeners();
        }

        function addEventListeners() {
            const models = document.querySelectorAll('mr-model');
            let flippedCards = [];

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            function placeModelsInGrid() {
                shuffleArray(models);
                const positions = ['-0.5 0 0', '-0.3 0 0', '-0.1 0 0', '0.1 0 0', '0.3 0 0', '-0.5 0.2 0', '-0.3 0.2 0', '-0.1 0.2 0', '0.1 0.2 0', '0.3 0.2 0'];
                shuffleArray(positions);
                models.forEach((model, index) => {
                    const position = positions[index];
                    model.setAttribute('data-position', position);
                });
            }

            function handleModelClick(event) {
                const model = event.target.closest('mr-model');
                const currentRotation = model.getAttribute('data-rotation') || '0 0 0';
                const [x, y, z] = currentRotation.split(' ').map(Number);
                const newRotation = `${x + 180} ${y} ${z}`;
                model.setAttribute('data-rotation', newRotation);
                flippedCards.push(model);
                if (flippedCards.length === 2) checkForMatch();
            }

            function checkForMatch() {
                const [firstCard, secondCard] = flippedCards;
                if (firstCard.getAttribute('name') === secondCard.getAttribute('name')) {
                    flippedCards = [];
                } else {
                    flippedCards.forEach(card => card.setAttribute('data-rotation', '90 0 0'));
                    flippedCards = [];
                }
            }

            models.forEach(model => model.addEventListener('click', handleModelClick));
            placeModelsInGrid();
        }

        document.addEventListener('DOMContentLoaded', () => {
            render();
        });

        document.addEventListener('anchored', (e) => {
            const painting = document.getElementById('paintings');
            if (e.target === painting.parentElement && e.target.plane) {
                let width = e.target.plane.dimensions.x - 0.01;
                let depth = e.target.plane.dimensions.z - 0.01;
                let height = width > depth ? width : depth;
                height /= 1.5;
                painting.mesh.geometry.copy(new THREE.BoxGeometry(width, height, depth));
            }
        });

        document.addEventListener('exitXR', () => {
            const volume = document.getElementById('volume');
            volume.object3D.visible = false;
        });
    </script>
</body>

</html>
